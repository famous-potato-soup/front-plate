{"version":3,"sources":["components/tsx/OAuthLogin.tsx","components/ts/Socket.ts","components/tsx/ReadyComponent.tsx","gameComponents/GameBoard.ts","components/board/Board.tsx","components/App.tsx","serviceWorker.ts","stores/modules/index.ts","index.tsx","stores/configureStore.ts","assets/img-logo.png","assets/loginOval.png","assets/oval.png","assets/img-win.png"],"names":["LoginComponents","styled","div","LoginComponent","useCookies","setCookie","className","src","logo","alt","appId","process","autoLoad","fields","callback","response","options","method","body","Blob","JSON","stringify","access_token","accessToken","type","mode","cache","fetch","then","r","token","headers","get","json","user","console","log","render","renderProps","onClick","Stone","Socket","socketio","connect","SocketClient","props","on","roomData","data","userData","name","email","userID","id","picture","url","emit","obj","Thumb_wrap","Info","ReadyComponent","onGameStart","cookie","removeCookie","stone","thumb","GameBoard","game","graphics","player","minimap","isDragging","this","setPhaserObjects","autoFocus","width","height","parent","onDestroy","Phaser","Game","AUTO","scale","Scale","ENVELOP","autoCenter","CENTER_BOTH","expandParent","physics","default","scene","create","createGame","update","updateGame","preload","preloadGameAssets","extend","setWorldBoundsAndCamera","setBackgrounds","drawBackgroundBorder","setPlayer","addDragEventListener","createPlayer","calculateWindowSize","load","image","matter","world","event","eventBodies","pairs","bodyA","isStatic","bodyB","label","setBounds","cameras","main","setZoom","add","setName","setBackgroundColor","actualWidth","window","innerWidth","actualHeight","innerHeight","canvasWidth","canvas","canvasHeight","canvasRatio","windowRatio","visibleCanvasHeight","setPosition","visibleCanvasWidth","tileSprite","MARGIN_OF_MAP","setOrigin","backgroundGraphics","lineStyle","moveTo","lineTo","stroke","startFollow","x","y","setCircle","setBounce","setFrictionAir","setIgnoreGravity","draggingIndicator","Geom","Line","draggingGraphics","input","pointer","worldX","worldY","clear","setTo","strokeLineShape","isDown","_","gameObject","velocityX","x1","x2","velocityY","y1","y2","setVelocity","Board","gameBoard","React","PureComponent","withCookies","useState","isGaming","setIsGaming","Boolean","location","hostname","match","combineReducers","ReactGA","initialize","pageview","pathname","search","store","createStore","modules","__REDUX_DEVTOOLS_EXTENSION__","ReactDOM","document","getElementById","navigator","serviceWorker","ready","registration","unregister","module","exports"],"mappings":"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","file":"static/js/main.c36c4060.chunk.js","sourcesContent":["import React from 'react';\nimport { useCookies } from 'react-cookie';\nimport FacebookLogin from 'react-facebook-login/dist/facebook-login-render-props';\nimport styled from 'styled-components';\n\nimport './OAuthLogin.css';\n\nimport logo from '../../assets/img-logo.png';\nimport Stone from '../../assets/loginOval.png';\n\nconst fbKey: any = process.env.REACT_APP_FACEBOOK_KEY;\nconst { REACT_APP_API_URL } = process.env;\n\nconst LoginComponents = styled.div`\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  height: 100%;\n`;\n\nconst LoginComponent = () => {\n  const [cookie, setCookie] = useCookies(['user']);\n  const handleFacebookLogin = (response: any): void => {\n    const tokenBlob = new Blob([JSON.stringify({ access_token: response.accessToken }, null, 2)], {\n      type: 'application/json',\n    });\n    const options: Object = {\n      method: 'POST',\n      body: tokenBlob,\n      mode: 'cors',\n      cache: 'default',\n    };\n    fetch(`${REACT_APP_API_URL}`, options).then(r => {\n      const token = r.headers.get('x-auth-token');\n      r.json().then(user => {\n        if (token) {\n          console.log(user, token);\n        }\n      });\n    });\n    setCookie('user', response);\n  };\n  return (\n    <LoginComponents className=\"LoginComponent\">\n      <div className=\"logoImg_wrap zOpt\">\n        <img src={logo} alt=\"logo\" className=\"logoImg\" />\n      </div>\n      <div className=\"Facebook_wrap zOpt\">\n        <FacebookLogin\n          appId={fbKey} // facebook developer 페이지에 생성한 앱의 아이디\n          autoLoad={false}\n          fields=\"name,email,picture\" // 페이스북에서 가져올 필드\n          callback={handleFacebookLogin} // 콜백함수 지정( container에 생성 )\n          // cssClass=\"my-facebook-button-class\"\n          render={renderProps => <button className=\"my-facebook-button-class\" onClick={renderProps.onClick}></button>}\n        />\n      </div>\n      <div className=\"logoImg_wrap bottom\">\n        <img src={Stone} alt=\"stone\" className=\"stone\" />\n      </div>\n    </LoginComponents>\n  );\n};\n\nexport default LoginComponent;\n","import socketio from 'socket.io-client';\n\nconst { REACT_APP_SOCKET_URL } = process.env;\n\n// 1, socket 연결\nconst Socket = socketio.connect(`${REACT_APP_SOCKET_URL}`);\n\n// const { Provider, Consumer } = React.createContext(defaultValue);\n\nconst SocketClient = props => {\n  Socket.on('gameStart', roomData => console.log(roomData));\n  Socket.on('shoot', data => console.log(data)); // 누가 쏴서 어디로 움직이는지 알기 위해서\n  Socket.on(\n    'moveEnd',\n    data => console.log(data),\n    // const moveEndData = {\n    //   tile,\n    //   player: [\n    //     stones: [],\n    //   ],\n    //   isGameFinished: boolean,\n    //   gameResult:{\n\n    //   }\n    // }\n  ); // 초를 막기 위해서 game끝나는 것 확인하기.\n  Socket.on('canShoot', data => console.log); // 중간에 악용하는 애들을 막기 위해서...\n  interface stonePush {\n    stoneId: number;\n    actor: string;\n    angle: number;\n    power: number;\n    currentPostion: Array<number>;\n  }\n  // user가 로그인을 하고 서버에 정보를 emit\n  const userData = {\n    name: props.user.name,\n    email: props.user.email,\n    userID: props.user.id,\n    picture: props.user.picture.data.url,\n  };\n  Socket.emit('userLogin', userData);\n  // 이름, 이메일, userID, picture url\n\n  // 2. 입장하기를 눌렀을 때 현재의 게임룸 상태를 받아오기\n  // 현재 방이 열려있는지, 혹은 시작한 상태인지, 새로 만들어야 되는 상태인지\n\n  const gameRoomStateData = {\n    id: 'uuid_strings', // uuid string, same as unique url\n    status: 'started', // enum value, [waiting, started, done]\n    mode: {\n      // judge win or loose, judging in backend\n      id: 1,\n      size: 2, // for player limit\n      name: 'classic push stone - 1vs 1',\n      isTurn: true, // turn base, e.g. my turn -> your turn -> my turn, false mean is realtime\n      turnLimit: 3000, // turn limit time, 0 is unlimit\n      actionDuration: 500, // time limit for after action\n      moveLimit: 0, // move limit per game, 0 is unlimit\n    },\n    user: {\n      player: [\n        // <player>, // has level, ability, game history(win, loose)\n        {\n          id: 'uuid',\n          name: 'nameeee',\n          won: 33,\n          loose: 67,\n          weight: 1, // play order, highest weight move first\n          stones: [\n            {\n              id: 'uuid',\n              position: {\n                lat: 3.3,\n                lon: 3.3,\n              },\n            },\n          ],\n        },\n      ],\n      observer: [\n        // <user>,\n        {\n          id: 'uuid',\n          name: 'nameeee',\n          won: 33,\n          loose: 67,\n        },\n      ],\n    },\n    tile: {\n      width: 1000,\n      height: 1000,\n    },\n    // events(push, crush), join, leave.... per game room\n    history: [\n      //<event>,\n      {\n        type: 'join_room', // define event types\n        actor: '<player_id>',\n      },\n    ],\n  };\n\n  Socket.on('gameRoomState', function(obj: any): void {\n    console.log(obj);\n    // 3. 그 다음 어떻게 행동해야될지 if문을 통해 emit 해주기\n\n    // gameroomState가 started 면 게임룸으로 redirect 해주기\n\n    // 3-1. 방이 없다면 만들기\n    if (true) {\n      //\n    }\n\n    // 3-2. 방에 입장하기\n    else if (false) {\n    }\n\n    // 3-3. 게임 중인 경우\n    else {\n    }\n  });\n\n  // 4. GameStart을 보내주고 내가 들어갈 gameRoomInfo를 기다림\n  // Socket.emit('gameStart', function(obj: any): void {\n  //   console.log(obj);\n\n  // });\n\n  //  => 정보를 가지고 퉁치자.\n\n  // 5. gameRoomInfo가 오면 경기장으로 입장 + 입장할 때의 돌의 랜덤 위치도 받아와야 할듯하다.\n  Socket.on('gameRoomInfo', function(obj: any): void {\n    console.log(obj);\n    // 하트비트처럼 사용할 듯\n  });\n\n  // 6. pushStone.\n  const pushStoneData = {\n    id: 'uuid',\n    owner: 'player_id',\n    position: {\n      lat: 3.3,\n      lon: 10,\n    },\n    action: {\n      power: 33,\n      degree: 90,\n    },\n  };\n  // Socket.emit(\"pushStone\", function(obj: any): void {\n  //   console.log(obj);\n  // });\n\n  // 7. game이 끝나는 이벤트.\n  Socket.on('finishGame', function(obj: any): void {\n    console.log(obj);\n    // 소켓을 안끊어도 괜찮을 지..\n  });\n\n  // 추가 사항\n  //1. crushStone이나 deadStone을 클라이언트에서 처리할지 서버에서 처리할지에 대한 상의 => 따로 넘겨주는 방식. 위치 부딪힌 돌들, timestamp => 판별로직 클라이언트\n  // 2. 게임이 끝나고 소켓연결 해지하는가\n};\n\nexport default SocketClient;\n","import React from 'react';\nimport { useCookies } from 'react-cookie';\nimport styled from 'styled-components';\nimport SocketClient from '../ts/Socket';\n\nimport stone from '../../assets/oval.png';\nimport thumb from '../../assets/img-win.png';\n\nconst Thumb_wrap = styled.div`\n  position: fixed;\n  z-index: 2;\n  bottom: 0;\n  left: 30%;\n`;\n\nconst Info = styled.div`\n  position: relative;\n  z-index: 3;\n`;\n\nexport interface ReadyComponentProps {\n  onGameStart: () => void;\n}\n\nconst ReadyComponent: React.FC<ReadyComponentProps> = ({ onGameStart }) => {\n  const [cookie, removeCookie] = useCookies(['user']);\n  const removeUserCookie = () => {\n    removeCookie('user', '');\n  };\n  if (cookie.user) {\n    SocketClient(cookie);\n  }\n\n  const handleGameStart = () => {\n    onGameStart();\n  };\n\n  return (\n    <div className=\"Info_wrap\">\n      <Info>\n        <div className=\"infoContent firstInfo\">\n          <div className=\"stoneInfo info\">\n            <img src={stone} alt=\"stone\" />\n          </div>\n          <div className=\"myInfo info\">\n            <div className=\"user-img\">\n              <img src={cookie.user.picture.data.url} />\n            </div>\n            <p className=\"user_name\"> {cookie.user.name}</p>\n            <p>{cookie.user.email}</p>\n          </div>\n        </div>\n        <div className=\"infoContent secondInfo\">\n          <div className=\"rank info\">\n            <h2>rank</h2>\n          </div>\n          <div className=\"start_wrap info\">\n            <button className=\"GameStart-btn\" onClick={handleGameStart}>\n              <p>Game Start</p>\n            </button>\n          </div>\n        </div>\n        <div className=\"logout-btn_wrap\">\n          <button className=\"logout-btn\" onClick={removeUserCookie}>\n            로그아웃\n          </button>\n        </div>\n      </Info>\n      <Thumb_wrap>\n        <img src={thumb} alt=\"thumb_img\" />\n      </Thumb_wrap>\n    </div>\n  );\n};\n\nexport default ReadyComponent;\n","// TODO game 오브젝트 destory할 때 window.onresize도 같이 해제해주세요!\nimport Phaser from 'phaser';\n\nconst MARGIN_OF_MAP = 0;\nconst MARGIN_OF_BORDER = 0;\nconst ZOOME_LEVEL_OF_CAMERA = 1.85;\nconst VELOCITY_FACTOR = 0.15;\nconst FRICTION_AIR = 0.08;\nconst BOUND_RATE = 2;\n\nconst DRAG_LINE_COLOR = 0x000000;\n\nconst MINIMAP_MARGIN = 50;\nconst MINIMAP_SIZE = 300;\n\nexport interface GameBoardOptions {\n  autoFocus: boolean;\n\n  width: number;\n  height: number;\n\n  parent?: string;\n\n  onDestroy: () => void;\n}\n\nclass GameBoard {\n  private options: GameBoardOptions;\n\n  public game?: Phaser.Game;\n  private graphics?: Phaser.GameObjects.Graphics;\n  private player?: Phaser.Physics.Matter.Image;\n\n  private minimap?: Phaser.Cameras.Scene2D.Camera;\n  private isDragging: boolean = false;\n\n  constructor(options: GameBoardOptions) {\n    this.options = options;\n\n    this.setPhaserObjects();\n  }\n\n  setPhaserObjects() {\n    const { autoFocus, width, height, parent, onDestroy } = this.options;\n\n    // game 오브젝트는 딱히 바뀔일이 없고 이게 바뀐다고 re-render할 필요는 없으니까\n    // 굳이 state로 쓰진 않는다.\n    this.game = new Phaser.Game({\n      autoFocus,\n      type: Phaser.AUTO,\n      parent,\n      scale: {\n        width,\n        height,\n        mode: Phaser.Scale.ENVELOP,\n        autoCenter: Phaser.Scale.CENTER_BOTH,\n        expandParent: true,\n      },\n      physics: {\n        default: 'matter',\n      },\n      scene: {\n        create: this.createGame,\n        update: this.updateGame,\n        preload: this.preloadGameAssets,\n        extend: {\n          setWorldBoundsAndCamera: this.setWorldBoundsAndCamera,\n          setBackgrounds: this.setBackgrounds,\n          drawBackgroundBorder: this.drawBackgroundBorder,\n          setPlayer: this.setPlayer,\n          addDragEventListener: this.addDragEventListener,\n          createPlayer: this.createPlayer,\n          calculateWindowSize: this.calculateWindowSize,\n          game: this.game,\n          onDestroy,\n        },\n      },\n    });\n  }\n\n  preloadGameAssets() {\n    /**\n     * CAUTION: \"this\" does not mean GameBoard class.\n     * This method is not binded to this class.\n     */\n    const scene: Phaser.Scene = (this as any) as Phaser.Scene;\n    scene.load.image('background-tile', '/static/in-game/background.png');\n    scene.load.image('player-black', '/static/in-game/player.png');\n  }\n\n  createGame() {\n    /**\n     * CAUTION: \"this\" does not mean GameBoard class.\n     * This method is not binded to this class.\n     */\n    const scene: Phaser.Scene = (this as any) as Phaser.Scene;\n\n    this.setWorldBoundsAndCamera(scene);\n    this.setBackgrounds(scene);\n    this.drawBackgroundBorder(scene);\n    this.setPlayer(scene);\n    this.addDragEventListener(scene);\n\n    scene.matter.world.on('collisionstart', (event: any) => {\n      const eventBodies = event.pairs[0];\n      if (\n        (eventBodies.bodyA.isStatic || eventBodies.bodyB.isStatic) &&\n        (eventBodies.bodyA.label == 'My Player' || eventBodies.bodyB.label == 'My Player')\n      ) {\n        console.log('Game Over');\n        (this as any).onDestroy();\n      }\n    });\n  }\n\n  setWorldBoundsAndCamera(scene: Phaser.Scene) {\n    scene.matter.world.setBounds();\n    scene.cameras.main.setZoom(ZOOME_LEVEL_OF_CAMERA);\n\n    this.minimap = scene.cameras.add(0, 0, MINIMAP_SIZE, MINIMAP_SIZE);\n    this.minimap.setZoom(0.2).setName('mini');\n    this.minimap.setBounds(0, 0, 1000, 1000);\n    this.minimap.setBackgroundColor(0xffffff);\n\n    this.calculateWindowSize(scene);\n  }\n\n  calculateWindowSize(scene: Phaser.Scene) {\n    const actualWidth = window.innerWidth;\n    const actualHeight = window.innerHeight;\n\n    const canvasWidth = scene.scale.canvas.width;\n    const canvasHeight = scene.scale.canvas.height;\n\n    const canvasRatio = canvasWidth / canvasHeight;\n    const windowRatio = actualWidth / actualHeight;\n\n    if (this.minimap) {\n      if (windowRatio > canvasRatio) {\n        // 실제 캔버스 비율보다 윈도우 비율이 폭이 길 때\n        // 그럼 높이를 신경써야 함\n        const visibleCanvasHeight = canvasWidth / windowRatio;\n        this.minimap.setPosition(\n          canvasWidth - MINIMAP_SIZE - MINIMAP_MARGIN,\n          canvasHeight - MINIMAP_SIZE - MINIMAP_MARGIN - (canvasHeight - visibleCanvasHeight) / 2,\n        );\n      } else if (windowRatio < canvasRatio) {\n        const visibleCanvasWidth = canvasHeight * windowRatio;\n        this.minimap.setPosition(\n          canvasWidth - MINIMAP_SIZE - MINIMAP_MARGIN - (canvasWidth - visibleCanvasWidth) / 2,\n          canvasHeight - MINIMAP_SIZE - MINIMAP_MARGIN,\n        );\n      } else {\n        this.minimap.setPosition(\n          canvasWidth - MINIMAP_SIZE - MINIMAP_MARGIN,\n          canvasHeight - MINIMAP_SIZE - MINIMAP_MARGIN,\n        );\n      }\n    }\n  }\n\n  setBackgrounds(scene: Phaser.Scene) {\n    scene.add\n      .tileSprite(\n        -MARGIN_OF_MAP,\n        -MARGIN_OF_MAP,\n        scene.scale.width + MARGIN_OF_MAP * 2,\n        scene.scale.height + MARGIN_OF_MAP * 2,\n        'background-tile',\n      )\n      .setOrigin(0);\n    scene.cameras.main.setBackgroundColor(0xffffff);\n  }\n\n  drawBackgroundBorder(scene: Phaser.Scene) {\n    const backgroundGraphics = scene.add.graphics();\n\n    backgroundGraphics.lineStyle(10, 0x000000, 1);\n    backgroundGraphics.moveTo(MARGIN_OF_BORDER, MARGIN_OF_BORDER);\n    backgroundGraphics.lineTo(scene.scale.width - MARGIN_OF_BORDER, MARGIN_OF_BORDER);\n    backgroundGraphics.lineTo(scene.scale.width - MARGIN_OF_BORDER, scene.scale.height - MARGIN_OF_BORDER);\n    backgroundGraphics.lineTo(MARGIN_OF_BORDER, scene.scale.height - MARGIN_OF_BORDER);\n    backgroundGraphics.lineTo(MARGIN_OF_BORDER, MARGIN_OF_BORDER);\n    backgroundGraphics.stroke();\n  }\n\n  setPlayer(scene: Phaser.Scene): Phaser.Physics.Matter.Image {\n    this.player = this.createPlayer(scene, 100, 100);\n    (this.player.body as any).label = 'My Player';\n    scene.cameras.main.startFollow(this.player, true);\n\n    this.createPlayer(scene, 300, 300);\n\n    return this.player;\n  }\n\n  createPlayer(scene: Phaser.Scene, x: number, y: number): Phaser.Physics.Matter.Image {\n    const player = scene.matter.add.image(x, y, 'player-black');\n    player.setCircle(player.width / 2, {});\n    player.setBounce(BOUND_RATE);\n    player.setFrictionAir(FRICTION_AIR);\n    player.setIgnoreGravity(true);\n\n    return player;\n  }\n\n  addDragEventListener(scene: Phaser.Scene) {\n    const draggingIndicator = new Phaser.Geom.Line();\n    const draggingGraphics = scene.add.graphics();\n    this.isDragging = false;\n\n    scene.input.on('pointerdown', (pointer: Phaser.Input.Pointer) => {\n      if (\n        this.player &&\n        pointer.worldX > this.player.x - 25 &&\n        pointer.worldX < this.player.x + 25 &&\n        pointer.worldY > this.player.y - 25 &&\n        pointer.worldY < this.player.y + 25\n      ) {\n        this.isDragging = true;\n        draggingGraphics.clear();\n        draggingGraphics.lineStyle(1, DRAG_LINE_COLOR, 1);\n\n        draggingIndicator.setTo(this.player.x, this.player.y, pointer.worldX, pointer.worldY);\n        draggingGraphics.strokeLineShape(draggingIndicator);\n      }\n    });\n\n    scene.input.on('pointermove', (pointer: Phaser.Input.Pointer) => {\n      if (pointer.isDown && this.isDragging && this.player) {\n        draggingIndicator.setTo(this.player.x, this.player.y, pointer.worldX, pointer.worldY);\n\n        draggingGraphics.clear();\n        draggingGraphics.lineStyle(1, DRAG_LINE_COLOR, 1);\n        draggingGraphics.strokeLineShape(draggingIndicator);\n      }\n    });\n\n    scene.input.on('pointerup', (_: any, gameObject: Phaser.Physics.Arcade.Image) => {\n      if (this.player && this.isDragging) {\n        this.isDragging = false;\n        draggingGraphics.clear();\n        const velocityX = draggingIndicator.x1 - draggingIndicator.x2;\n        const velocityY = draggingIndicator.y1 - draggingIndicator.y2;\n\n        this.player.setVelocity(velocityX * VELOCITY_FACTOR, velocityY * VELOCITY_FACTOR);\n      }\n    });\n  }\n\n  updateGame(data: object) {\n    if (!this.graphics) return;\n  }\n}\n\nexport default GameBoard;\n","import React from 'react';\n\nimport { GameBoard } from '../../gameComponents';\n\nimport './Board.css';\n\nexport interface BoardProps {\n  onDestroy: () => void;\n}\n\nclass Board extends React.PureComponent<BoardProps> {\n  private gameBoard?: GameBoard;\n\n  componentDidMount() {\n    this.gameBoard = new GameBoard({\n      autoFocus: true,\n      width: 1500,\n      height: 1500,\n      parent: 'phaser-parent',\n      onDestroy: this.onDestroy,\n    });\n  }\n\n  onDestroy = () => {\n    this.props.onDestroy();\n  };\n\n  render() {\n    // 어차피 한 페이지에 하나 마운트할 거니까 괜찮지 않을까...?\n    return <div id=\"phaser-parent\"></div>;\n  }\n}\n\nexport default Board;\n","import React, { useState } from 'react';\nimport './App.css';\n\nimport { withCookies, useCookies } from 'react-cookie';\n\nimport LoginComponent from './tsx/OAuthLogin';\nimport ReadyComponent from './tsx/ReadyComponent';\nimport { Board } from './board';\n\nconst App: React.FC = () => {\n  const [isGaming, setIsGaming] = useState<boolean>(true);\n  const [cookie] = useCookies(['user']);\n\n  const handleGameStart = () => {\n    setIsGaming(true);\n  };\n\n  const handleDestroy = () => {\n    setIsGaming(false);\n  };\n\n  return (\n    <div className=\"App\">\n      <div className=\"content\">\n        {cookie.user ? (\n          isGaming ? (\n            <Board onDestroy={handleDestroy} />\n          ) : (\n            <ReadyComponent onGameStart={handleGameStart} />\n          )\n        ) : (\n          <LoginComponent />\n        )}\n      </div>\n      {/* <WinComponent /> */}\n    </div>\n  );\n};\n\nexport default withCookies(App);\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/),\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL((process as { env: { [key: string]: string } }).env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA',\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.',\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (response.status === 404 || (contentType != null && contentType.indexOf('javascript') === -1)) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import { combineReducers } from 'redux';\n// import { TodoState, todoReducer as todo } from './todos';\n\nexport interface StoreState {\n  // todos: TodoState;\n}\n\nexport default combineReducers<StoreState>({\n  // todos\n});\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nimport { CookiesProvider } from 'react-cookie';\nimport { Provider } from 'react-redux';\nimport configureStore from './stores/configureStore';\n\nimport ReactGA from 'react-ga';\nReactGA.initialize('UA-147950989-1');\nReactGA.pageview(window.location.pathname + window.location.search);\n\nconst store = configureStore();\n\nReactDOM.render(\n  <Provider store={store}>\n    <CookiesProvider>\n      <App />\n    </CookiesProvider>\n  </Provider>,\n  document.getElementById('root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import modules, { StoreState } from './modules';\nimport { createStore, Store } from 'redux';\n\nexport default function configureStore(): Store<StoreState> {\n  const store = createStore(\n    modules,\n    (window as any).__REDUX_DEVTOOLS_EXTENSION__ && (window as any).__REDUX_DEVTOOLS_EXTENSION__(),\n  );\n  return store;\n}\n","module.exports = __webpack_public_path__ + \"static/media/img-logo.2809a28a.png\";","module.exports = __webpack_public_path__ + \"static/media/loginOval.5d48089f.png\";","module.exports = __webpack_public_path__ + \"static/media/oval.99a2a003.png\";","module.exports = __webpack_public_path__ + \"static/media/img-win.2f43965a.png\";"],"sourceRoot":""}